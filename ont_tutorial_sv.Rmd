---
title: "Whole genome structural variation analysis using Nanopore long DNA sequence reads"
date: "Report created: `r Sys.Date()`"
output:
  html_document:
    keep_md: yes
    number_sections: yes
    self_contained: yes
    theme: default
    highlight: null
    css: Static/ont_tutorial.css
    toc: yes
    toc_depth: 2
    toc_float:
      collapsed: yes
      smooth_scroll: yes
    df_print: paged
link-citations: yes
bibliography: Static/Bibliography.bib
always_allow_html: yes
---

<div style="position:absolute;top:0px;right:0px;padding:15px;background-color:gray;width:45%;">
```{r, echo=FALSE}
knitr::include_graphics("https://nanoporetech.com/themes/custom/nanopore/images/ont-logo.svg?tutorial=sv")
```
</div>


```{r setup, include=FALSE}
knitr::opts_chunk$set(tidy=TRUE, tidy.opts=list(width.cutoff=80), 
                      fig.width=9, fig.height=6, warning=FALSE, message=FALSE, 
                      kable.force.latex=TRUE,
                      highlight=TRUE,
                      cache.path="Analysis/Cache/",
                      knitr.table.format = "html",
                      width = 120,
                      knitr.kable.NA = '')

options(knitr.kable.NA = '')

library(yaml)
library(session)
library(kableExtra)
library(scales) # required for comma
library(dplyr)
library(nanopoRe) # devtools::install_github("sagrudd/nanopoRe") # unloadNamespace("nanopoRe")
library(emojifont)
library(vcfR)
library(VariantAnnotation)

config <- yaml.load_file("config.yaml")
#tutorialText   <- config$tutorialText
tutorialText <- TRUE

sample_name <- config$sample_name
input_fastq <- file.path(basename(dirname(config$input_fastq)), basename(config$input_fastq))
reference_fasta <- file.path(basename(dirname(config$reference_fasta)), basename(config$reference_fasta))

### here lie dragons ###
# expeditions below this comment at your own risk
# welcome feedback and suggestions ...

slurpContent <- function(filename) {
  include = as.logical(tutorialText)
  if (include) {
    paste(readLines(filename),collapse="\n")
  }
}

setRpath(file.path("Analysis", "R"))
setReferenceGenome(reference_fasta)
bamFile <- file.path("Analysis", sample_name, "alignment", paste0(sample_name, "_minimap2.bam"))
vcfFile <- file.path("Analysis", sample_name, "sv_calls", paste0(sample_name, "_sniffles_filtered.vcf.gz"))

# load the annotation packages that will be used presently ...
# this is a little ugly; but is is moving the package definitions into config.yaml; will try to install missing
# packages - what could possibly go wrong ...
biocGenome <- config$biocGenome
if (!config$GeneIdMappings %in% installed.packages()[, "Package"]) {BiocManager::install(config$GeneIdMappings)}
library(eval(config$GeneIdMappings), character.only=TRUE)
if (!config$GenomeAnnotation %in% installed.packages()[, "Package"]) {BiocManager::install(config$GenomeAnnotation)}
library(eval(config$GenomeAnnotation), character.only=TRUE)
eval(parse(text=paste0("txdb <- ",config$GenomeAnnotation)))
```


`r slurpContent("Static/TutorialPreamble.md")`




# Study design

The **`ont_tutorial_sv`** script has been used to generate this report. The configuration file, **`config.yaml`** has been parsed and the fastq format DNA sequence file has been identified as **` `r input_fastq` `**.

```{r fastqSummary, cache=FALSE, echo=FALSE}
if (!file.exists(input_fastq)) {
  cat(paste0("Fatal error - file ["+input_fastq+"] not found\n\n"))
  knitr::knit_exit()
}
validationResponse = fastqCheckup(input_fastq)
if (is.logical(validationResponse)) {
  if (validationResponse==FALSE) {
    cat(paste0("Fatal error - file ["+input_fastq+"] corrupt or not FASTQ format\n\n"))
    knitr::knit_exit()
  }
}

file.data <- t(data.frame(validationResponse[1:5]))

kable(file.data, format="html", caption="Table summarising provided FASTQ file content", booktabs=TRUE, table.envir='table*', linesep="", escape = FALSE, row.names=FALSE)  %>%
  kable_styling(c("striped", "condensed")) %>%
  footnote(symbol=c("Md5 checksum calculated using R digest package"), symbol_title="please note: ", footnote_as_chunk = TRUE)
```


# Mapping Summary

```{r mappingExecutiveSummary, echo=FALSE, message=FALSE}
bamSummary <- bamSummarise(bamFile)
primaryBAM <- bamSummary[which(bamSummary$readFlag=="Primary"),]

infographicFile <- infoGraphicPlot4(identifier="mappingSummary", 
                 panelA=c(key="Primary Alignments", value=scales::comma_format()(nrow(primaryBAM)), icon="fa-sliders"), 
                 panelB=c(key="Mapping Yield", value=gdata::humanReadable(sum(primaryBAM$end - primaryBAM$start), standard="SI"), icon="fa-calculator"), 
                 panelC=c(key="Average Accuracy", value=paste0(round(mean(primaryBAM$accuracy)*100,digits=1),"%"), icon="fa-area-chart"), 
                 panelD=c(key="Average Identity", value=paste0(round(mean(primaryBAM$identity)*100,digits=1),"%"), icon="fa-info"))

 knitr::include_graphics(infographicFile)
```

## Assessment of mapping quality and identity

The graphic above has summarised the dimensions of the mapped data. 

```{r mappingIdentity, echo=FALSE, message=FALSE}

p1 <- plotAlignmentAccuracy(bamFile, lower=0.75) 

p2 <- plotAlignmentIdentity(bamFile, lower=0.75)

LeftRightPlot(p1, p2)

```


# Mapping characteristics

```{r loadMapData, echo=FALSE, warning=FALSE, message=FALSE}

if (!file.exists(bamFile)) {
  cat(paste0("Fatal error - file ["+bamFile+"] not found\n\n"))
  knitr::knit_exit()
}

# load the mapping data
bamSummary <- bamSummarise(bamFile, blockSize=10000)

SVMappingCharacteristicTable(bamSummary, validationResponse, bamFile)
```

  
```{r mappingAccuracy, echo=FALSE, warning=FALSE, message=FALSE}

nul <- capture.output(covHist <- plotOverallCovHistogram(bamFile))
print(covHist)

```
  
  
  
```{r chromosomeByChromosome, echo=FALSE, message=FALSE}

chrIds <- getChromosomeIds()
chrIds <- chrIds[grep("(MT)|(\\.)", chrIds, invert=TRUE)]

chrMapping <- chromosomeMappingSummary(chrIds, bamFile)

kable(chrMapping, format="html", caption="Table summarising mapping characteristics", booktabs=TRUE, table.envir='table*', linesep="", escape = FALSE) %>%
  kable_styling(c("striped", "condensed"))

```
  




  
  
  


```{r bamSum, warning=FALSE, echo=FALSE, message=FALSE}
suppressWarnings(coverageData <- bamSummaryToCoverage(bamFile, tilewidth=250000))
# filter out the non-canonical chromosomes ...
coverageData <- coverageData[-grep("(MT)|(\\.)", as.character(seqnames(coverageData))),]

plotDepthOfCoverageMegablock(coverageData)
```
  
  



# Investigation of VCF file produced by Sniffles

parsing the VCF makes more sense than relying on existing parsers; large deletions are not properly defined within the ALT/REF fields and need to be parsed from variant INFO field

## Structural Variants - Executive Summary


```{r vcfSummary, echo=FALSE, warning=FALSE, message=FALSE}

nul <- capture.output(ins <- Vcf2FilteredGranges(vcfFile, svtype="INS"))
nul <- capture.output(del <- Vcf2FilteredGranges(vcfFile, svtype="DEL"))
nul <- capture.output(dup <- Vcf2FilteredGranges(vcfFile, svtype="DUP"))

infographicFile2 <- infoGraphicPlot3(identifier="SV_types", 
                 panelA=c(key="Insertions",   value=scales::comma_format()(length(ins)), icon="fa-chevron-down"), 
                 panelB=c(key="Deletions",    value=scales::comma_format()(length(del)), icon="fa-cut"), 
                 panelC=c(key="Duplications", value=scales::comma_format()(length(dup)), icon="fa-paperclip"))

 knitr::include_graphics(infographicFile2)
```

```{r SVsummarytable, echo=FALSE}
SVsummary <- NULL
SVsummary <- rbind(SVsummary, c("Insertion", 
                                scales::comma_format()(length(ins)), 
                                round(mean(ins$SVLEN), digits=2), 
                                min(ins$SVLEN), 
                                scales::comma_format()(max(ins$SVLEN))))
SVsummary <- rbind(SVsummary, c("Deletion", 
                                scales::comma_format()(length(del)), 
                                round(mean(del$SVLEN), digits=2), 
                                min(del$SVLEN), 
                                scales::comma_format()(max(del$SVLEN))))
SVsummary <- rbind(SVsummary, c("Duplication", 
                                scales::comma_format()(length(dup)), 
                                round(mean(dup$SVLEN), digits=2), 
                                min(dup$SVLEN), 
                                scales::comma_format()(max(dup$SVLEN))))

kable(SVsummary, format="html", col.names=c("SV type", "Count", "Mean size (nt)", "Shortest (nt)", "Longest (nt)"), caption="Table summarising types of structural variations called", booktabs=TRUE, table.envir='table*', linesep="", escape = FALSE) %>% kable_styling(c("striped", "condensed"))

```


```{r svLengthDistribution, echo=FALSE}
nul <- capture.output(svdist <- svLengthDistribution(vcfFile))
print(svdist)
```



```{r karyogram, echo=FALSE, warning=FALSE, message=FALSE}

nul <- capture.output(karyogram <- snifflesKaryogram(vcfFile))
print(karyogram)

```

# Genomic placement of SVs in annotated genome.

Genes are characterised by patterns of large introns, short exons and various regulatory regions - and are themselves interspersed by typically large intergenic regions. When considering the collections of structural variations identified, it is useful to consider how the structural variations are placed within the genome. 


```{r loadVcf, echo=FALSE, message=FALSE, warning=FALSE, results='hide'}
vcf <- readVcf(file=vcfFile, genome=biocGenome)
vcf <- trim(vcf)

seqlevels(vcf) <- paste0("chr",seqlevels(vcf))
seqlevels(vcf, pruning.mode="coarse") <- seqlevels(vcf)[which(seqlevels(vcf) %in% seqlevels(txdb))]

suppressWarnings(variantsGR <- locateVariants(rowRanges(vcf), txdb, AllVariants()))
# filter on some key columns; remove e.g. the TXID and CDSID that lead to duplicates ...
variants <- data.frame(variantsGR)[,c("seqnames", "start", "end", "width", "LOCATION", "QUERYID", "GENEID")]
variants <- variants[!duplicated(variants),]
vcfMeta <- Vcf2GRanges(vcfFile)

genic <- data.frame(variants[which(variants$LOCATION == "coding"),])
genic$SVTYPE <- as.character(vcfMeta[genic$QUERYID,]$SVTYPE)
genic$SVLEN <- as.character(vcfMeta[genic$QUERYID,]$SVLEN)
genic$SYMBOL <- as.character(mapIds(org.Hs.eg.db, keys=genic$GENEID, column="SYMBOL", keytype="ENTREZID"))
```

```{r genomeComponentTable, echo=FALSE}
svloctable <- as.data.frame(table(as.character(variants$LOCATION)))

svloctable$genes <- lapply(svloctable$Var1, function(x) { length(which(!is.na(unique(variants[which(variants$LOCATION==x),"GENEID"])))) })
svloctable$del <- lapply(svloctable$Var1, function(x) { length(which(mcols(vcfMeta[variants[which(variants$LOCATION==x),"QUERYID"],])$SVTYPE=="DEL")) })
svloctable$ins <- lapply(svloctable$Var1, function(x) { length(which(mcols(vcfMeta[variants[which(variants$LOCATION==x),"QUERYID"],])$SVTYPE=="INS")) })
svloctable$dup <- lapply(svloctable$Var1, function(x) { length(which(mcols(vcfMeta[variants[which(variants$LOCATION==x),"QUERYID"],])$SVTYPE=="DUP")) })

kable(svloctable, format="html", col.names=c("SV location", "Count", "Genes", "Deletions", "Insertions", "Duplications"), caption="Table summarising the genomic location of SVs called", booktabs=TRUE, table.envir='table*', linesep="") %>% kable_styling(c("striped", "condensed"))
```


The **coding** SVs identified in the table above, overlap with annotated gene exons. A deletion, insertion, or duplication event may have functional implications. 

```{r codingRegions, echo=FALSE, message=FALSE, warning=FALSE}

genes       <- sort(unique(genic[which(genic$SYMBOL!="NULL"),"SYMBOL"]))
deletions   <- unlist(lapply(genes, function(x) { length(which(genic[which(genic$SYMBOL==x),"SVTYPE"]=="DEL")) }))
insertions  <- unlist(lapply(genes, function(x) { length(which(genic[which(genic$SYMBOL==x),"SVTYPE"]=="INS")) }))
duplications<- unlist(lapply(genes, function(x) { length(which(genic[which(genic$SYMBOL==x),"SVTYPE"]=="DUP")) }))
vsizes      <- unlist(lapply(genes, function(x) { round(mean(as.integer(genic[which(genic$SYMBOL==x),"SVLEN"]))) }))
chromosome  <- unlist(lapply(genes, function(x) { unique(as.character(genic[which(genic$SYMBOL==x),"seqnames"])) }))

geneAssociation <- cbind(genes, chromosome, deletions, insertions, duplications, vsizes)
geneAssociation[geneAssociation=="0"] <- " "


kable(geneAssociation, format="html", col.names=c("GeneId", "Chromosome", "Deletions", "Insertions", "Duplications", "Mean variant size"), caption="Table listing genes containing SVs, the SV type and SV size", booktabs=TRUE, table.envir='table*', linesep="") %>% kable_styling(c("striped", "condensed"))
```


The table above shows how most structural variants are located in the non-protein coding regions of the genome; the majority being within either annotated introns or within the intergenic space. There are however a number of SVs within the the protein-coding space of the genome. It is helpful to identify the genes that are associated with the structural variants identified.



# Structural Variations and Genomic Repeat Analysis

```{r RepeatMasker, echo=FALSE, message=FALSE, warning=FALSE, results='hide'} 

RepeatGR <- RepeatMaskerGR()
SV <- Vcf2GRanges(vcfFile)
seqlengths(SV) <- getSeqLengths(names(seqlengths(SV)))

suppressWarnings(real <- RepeatGR[queryHits(findOverlaps(RepeatGR, SV))])
realDF <- as.data.frame(table(real$repeatClass))

repeatResults <- realDF[order(realDF$Freq, decreasing=TRUE),][1:15,]

x <- lapply(repeatResults$Var1, function(x) {
  
  svtargets <- to(findOverlaps(real[which(real$repeatClass == x),], SV, ignore.strand=TRUE))
  repeatSV <- SV[unique(svtargets),]
  return(c(length(unique(svtargets)), 
           length(which(repeatSV$SVTYPE=="DEL")), 
           length(which(repeatSV$SVTYPE=="INS")), 
          length(which(repeatSV$SVTYPE=="DUP"))))
} )
repeatResults <- cbind(repeatResults, t(as.data.frame(x)))
```

```{r repeatAnalysisTable, echo=FALSE}
kable(repeatResults, format="html", col.names=c("Repeat Class", "Frequency", "Unique SV", "Deletions", "Insertions", "Duplications"), caption="Counts of SVs overlapping with annotated Repeatmasker repeats", booktabs=TRUE, table.envir='table*', linesep="", row.names = FALSE) %>% kable_styling(c("striped", "condensed"))
```



# Review of performance against a truthset

This tutorial has used the **`pipeline-structural-variation`** workflow to identify candidate structural variants from the specified dataset. The data included within the tutorial is a subset of sequence data from **`Genome in a Bottle (GIAB)`**. The sequence data used corresponds to whole genome sequence data for individual **`GM002`** - the son from the Ashkenazim trio sequencing study. The GIAB consortium have published a truthset of structural variants for this GM002 individual that have been identified and validated using a variety of DNA sequence analysis methods and have been associated with the parental genomes. The [VCF file for the validated structural variations](https://ftp-trace.ncbi.nlm.nih.gov/giab/ftp/data/AshkenazimTrio/analysis/NIST_SVs_Integration_v0.6/) is available from the GIAB project.

Software such as [Truvari](https://github.com/spiralgenetics/truvari/) has been written to enable the comparison of observed datasets against appropriate data truthsets. The **`Snakefile`** used to perform the structural variation analysis earlier within the tutorial also includes a **`target`** to perform benchmarking of the **`pipeline-structural-variation`** performance.


This **`snakemake`** command performs x tasks

* the GIAB truthset data are downloaded from the [NCBI ftp server](https://ftp-trace.ncbi.nlm.nih.gov/giab/ftp/data/AshkenazimTrio/analysis/NIST_SVs_Integration_v0.6/)
* **`bedtools`** is used to identify the genomic regions intersecting between the GIAB truthset and the genomic regions investigated within this tutorial (the example dataset, for example, is looking at just human chromosome 20)
* **`Truvari`** is used to compare the high-confidence set of SVs identified by Sniffles with the truthset SVs for genomic regions identified in the intersecting **`bedfile`**
* summary statistics and performance metrics are written to a **`YAML`** file that can be parsed

The summary statistics reveal the following information for the dataset evaluated.


```{r truthset, echo=FALSE}

infographicFile3 <- infoGraphicPlot3(identifier="truthset_validation", 
                 panelA=c(key="Precision",   value="0.951", icon="fa-dot-circle-o"), 
                 panelB=c(key="Recall",    value="0.949", icon="fa-braille"), 
                 panelC=c(key="F1 score", value="95.0", icon="fa-percent"))

 knitr::include_graphics(infographicFile3)
```




# Reproducible research - produce your own report

This report has been created using **`Rmarkdown`**, publicly available **`R`** packages, and the \LaTeX document typesetting software for reproducibility. For clarity the **`R`** packages used, and their versions, are listed below.

\fontsize{8}{12}

```{r sessionInfo, eval=TRUE, echo=FALSE, comment=NA}
utils:::print.sessionInfo(sessionInfo()[-7], locale=FALSE)
```

\fontsize{10}{14}

It is also worth recording the versions of the software that have been used for the analysis.

\fontsize{8}{12}

```{r, engine='bash', echo=FALSE, comment=NA}
conda list "samtools|minimap2|sniffles|snakemake|rstudio"
```

\fontsize{10}{14}

`r slurpContent("Static/TutorialPostamble.md")`

\pagebreak


# References and citations
